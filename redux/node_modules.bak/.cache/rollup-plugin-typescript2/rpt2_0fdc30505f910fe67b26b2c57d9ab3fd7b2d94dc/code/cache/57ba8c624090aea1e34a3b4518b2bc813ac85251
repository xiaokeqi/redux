{"code":"import $$observable from './utils/symbol-observable';\r\nimport ActionTypes from './utils/actionTypes';\r\nimport isPlainObject from './utils/isPlainObject';\r\nexport default function createStore(reducer, preloadedState, enhancer) {\r\n    if ((typeof preloadedState === 'function' && typeof enhancer === 'function') ||\r\n        (typeof enhancer === 'function' && typeof arguments[3] === 'function')) {\r\n        throw new Error('It looks like you are passing several store enhancers to ' +\r\n            'createStore(). This is not supported. Instead, compose them ' +\r\n            'together to a single function.');\r\n    }\r\n    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\r\n        enhancer = preloadedState;\r\n        preloadedState = undefined;\r\n    }\r\n    if (typeof enhancer !== 'undefined') {\r\n        if (typeof enhancer !== 'function') {\r\n            throw new Error('Expected the enhancer to be a function.');\r\n        }\r\n        return enhancer(createStore)(reducer, preloadedState);\r\n    }\r\n    if (typeof reducer !== 'function') {\r\n        throw new Error('Expected the reducer to be a function.');\r\n    }\r\n    let currentReducer = reducer;\r\n    let currentState = preloadedState;\r\n    let currentListeners = [];\r\n    let nextListeners = currentListeners;\r\n    let isDispatching = false;\r\n    /**\r\n     * This makes a shallow copy of currentListeners so we can use\r\n     * nextListeners as a temporary list while dispatching.\r\n     *\r\n     * This prevents any bugs around consumers calling\r\n     * subscribe/unsubscribe in the middle of a dispatch.\r\n     */\r\n    function ensureCanMutateNextListeners() {\r\n        if (nextListeners === currentListeners) {\r\n            nextListeners = currentListeners.slice();\r\n        }\r\n    }\r\n    /**\r\n     * Reads the state tree managed by the store.\r\n     *\r\n     * @returns The current state tree of your application.\r\n     */\r\n    function getState() {\r\n        if (isDispatching) {\r\n            throw new Error('You may not call store.getState() while the reducer is executing. ' +\r\n                'The reducer has already received the state as an argument. ' +\r\n                'Pass it down from the top reducer instead of reading it from the store.');\r\n        }\r\n        return currentState;\r\n    }\r\n    /**\r\n     * Adds a change listener. It will be called any time an action is dispatched,\r\n     * and some part of the state tree may potentially have changed. You may then\r\n     * call `getState()` to read the current state tree inside the callback.\r\n     *\r\n     * You may call `dispatch()` from a change listener, with the following\r\n     * caveats:\r\n     *\r\n     * 1. The subscriptions are snapshotted just before every `dispatch()` call.\r\n     * If you subscribe or unsubscribe while the listeners are being invoked, this\r\n     * will not have any effect on the `dispatch()` that is currently in progress.\r\n     * However, the next `dispatch()` call, whether nested or not, will use a more\r\n     * recent snapshot of the subscription list.\r\n     *\r\n     * 2. The listener should not expect to see all state changes, as the state\r\n     * might have been updated multiple times during a nested `dispatch()` before\r\n     * the listener is called. It is, however, guaranteed that all subscribers\r\n     * registered before the `dispatch()` started will be called with the latest\r\n     * state by the time it exits.\r\n     *\r\n     * @param listener A callback to be invoked on every dispatch.\r\n     * @returns A function to remove this change listener.\r\n     */\r\n    function subscribe(listener) {\r\n        if (typeof listener !== 'function') {\r\n            throw new Error('Expected the listener to be a function.');\r\n        }\r\n        if (isDispatching) {\r\n            throw new Error('You may not call store.subscribe() while the reducer is executing. ' +\r\n                'If you would like to be notified after the store has been updated, subscribe from a ' +\r\n                'component and invoke store.getState() in the callback to access the latest state. ' +\r\n                'See https://redux.js.org/api-reference/store#subscribelistener for more details.');\r\n        }\r\n        let isSubscribed = true;\r\n        ensureCanMutateNextListeners();\r\n        nextListeners.push(listener);\r\n        return function unsubscribe() {\r\n            if (!isSubscribed) {\r\n                return;\r\n            }\r\n            if (isDispatching) {\r\n                throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' +\r\n                    'See https://redux.js.org/api-reference/store#subscribelistener for more details.');\r\n            }\r\n            isSubscribed = false;\r\n            ensureCanMutateNextListeners();\r\n            const index = nextListeners.indexOf(listener);\r\n            nextListeners.splice(index, 1);\r\n            currentListeners = null;\r\n        };\r\n    }\r\n    /**\r\n     * Dispatches an action. It is the only way to trigger a state change.\r\n     *\r\n     * The `reducer` function, used to create the store, will be called with the\r\n     * current state tree and the given `action`. Its return value will\r\n     * be considered the **next** state of the tree, and the change listeners\r\n     * will be notified.\r\n     *\r\n     * The base implementation only supports plain object actions. If you want to\r\n     * dispatch a Promise, an Observable, a thunk, or something else, you need to\r\n     * wrap your store creating function into the corresponding middleware. For\r\n     * example, see the documentation for the `redux-thunk` package. Even the\r\n     * middleware will eventually dispatch plain object actions using this method.\r\n     *\r\n     * @param action A plain object representing “what changed”. It is\r\n     * a good idea to keep actions serializable so you can record and replay user\r\n     * sessions, or use the time travelling `redux-devtools`. An action must have\r\n     * a `type` property which may not be `undefined`. It is a good idea to use\r\n     * string constants for action types.\r\n     *\r\n     * @returns For convenience, the same action object you dispatched.\r\n     *\r\n     * Note that, if you use a custom middleware, it may wrap `dispatch()` to\r\n     * return something else (for example, a Promise you can await).\r\n     */\r\n    function dispatch(action) {\r\n        if (!isPlainObject(action)) {\r\n            throw new Error('Actions must be plain objects. ' +\r\n                'Use custom middleware for async actions.');\r\n        }\r\n        if (typeof action.type === 'undefined') {\r\n            throw new Error('Actions may not have an undefined \"type\" property. ' +\r\n                'Have you misspelled a constant?');\r\n        }\r\n        if (isDispatching) {\r\n            throw new Error('Reducers may not dispatch actions.');\r\n        }\r\n        try {\r\n            isDispatching = true;\r\n            currentState = currentReducer(currentState, action);\r\n        }\r\n        finally {\r\n            isDispatching = false;\r\n        }\r\n        const listeners = (currentListeners = nextListeners);\r\n        for (let i = 0; i < listeners.length; i++) {\r\n            const listener = listeners[i];\r\n            listener();\r\n        }\r\n        return action;\r\n    }\r\n    /**\r\n     * Replaces the reducer currently used by the store to calculate the state.\r\n     *\r\n     * You might need this if your app implements code splitting and you want to\r\n     * load some of the reducers dynamically. You might also need this if you\r\n     * implement a hot reloading mechanism for Redux.\r\n     *\r\n     * @param nextReducer The reducer for the store to use instead.\r\n     * @returns The same store instance with a new reducer in place.\r\n     */\r\n    function replaceReducer(nextReducer) {\r\n        if (typeof nextReducer !== 'function') {\r\n            throw new Error('Expected the nextReducer to be a function.');\r\n        }\r\n        // TODO: do this more elegantly\r\n        ;\r\n        currentReducer = nextReducer;\r\n        // This action has a similar effect to ActionTypes.INIT.\r\n        // Any reducers that existed in both the new and old rootReducer\r\n        // will receive the previous state. This effectively populates\r\n        // the new state tree with any relevant data from the old one.\r\n        dispatch({ type: ActionTypes.REPLACE });\r\n        // change the type of the store by casting it to the new store\r\n        return store;\r\n    }\r\n    /**\r\n     * Interoperability point for observable/reactive libraries.\r\n     * @returns A minimal observable of state changes.\r\n     * For more information, see the observable proposal:\r\n     * https://github.com/tc39/proposal-observable\r\n     */\r\n    function observable() {\r\n        const outerSubscribe = subscribe;\r\n        return {\r\n            /**\r\n             * The minimal observable subscription method.\r\n             * @param observer Any object that can be used as an observer.\r\n             * The observer object should have a `next` method.\r\n             * @returns An object with an `unsubscribe` method that can\r\n             * be used to unsubscribe the observable from the store, and prevent further\r\n             * emission of values from the observable.\r\n             */\r\n            subscribe(observer) {\r\n                if (typeof observer !== 'object' || observer === null) {\r\n                    throw new TypeError('Expected the observer to be an object.');\r\n                }\r\n                function observeState() {\r\n                    const observerAsObserver = observer;\r\n                    if (observerAsObserver.next) {\r\n                        observerAsObserver.next(getState());\r\n                    }\r\n                }\r\n                observeState();\r\n                const unsubscribe = outerSubscribe(observeState);\r\n                return { unsubscribe };\r\n            },\r\n            [$$observable]() {\r\n                return this;\r\n            }\r\n        };\r\n    }\r\n    // When a store is created, an \"INIT\" action is dispatched so that every\r\n    // reducer returns their initial state. This effectively populates\r\n    // the initial state tree.\r\n    dispatch({ type: ActionTypes.INIT });\r\n    const store = {\r\n        dispatch: dispatch,\r\n        subscribe,\r\n        getState,\r\n        replaceReducer,\r\n        [$$observable]: observable\r\n    };\r\n    return store;\r\n}\r\n//# sourceMappingURL=createStore.js.map","references":["/Users/lidandan/beike/demo/redux/redux/src/utils/symbol-observable.ts","/Users/lidandan/beike/demo/redux/redux/src/types/store.ts","/Users/lidandan/beike/demo/redux/redux/src/types/actions.ts","/Users/lidandan/beike/demo/redux/redux/src/types/reducers.ts","/Users/lidandan/beike/demo/redux/redux/src/utils/actionTypes.ts","/Users/lidandan/beike/demo/redux/redux/src/utils/isPlainObject.ts"],"map":"{\"version\":3,\"file\":\"createStore.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/createStore.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/lidandan/beike/demo/redux/redux/types/createStore.d.ts","writeByteOrderMark":false,"text":"import { Store, PreloadedState, StoreEnhancer, ExtendState } from './types/store';\r\nimport { Action } from './types/actions';\r\nimport { Reducer } from './types/reducers';\r\n/**\r\n * Creates a Redux store that holds the state tree.\r\n * The only way to change the data in the store is to call `dispatch()` on it.\r\n *\r\n * There should only be a single store in your app. To specify how different\r\n * parts of the state tree respond to actions, you may combine several reducers\r\n * into a single reducer function by using `combineReducers`.\r\n *\r\n * @param reducer A function that returns the next state tree, given\r\n * the current state tree and the action to handle.\r\n *\r\n * @param preloadedState The initial state. You may optionally specify it\r\n * to hydrate the state from the server in universal apps, or to restore a\r\n * previously serialized user session.\r\n * If you use `combineReducers` to produce the root reducer function, this must be\r\n * an object with the same shape as `combineReducers` keys.\r\n *\r\n * @param enhancer The store enhancer. You may optionally specify it\r\n * to enhance the store with third-party capabilities such as middleware,\r\n * time travel, persistence, etc. The only store enhancer that ships with Redux\r\n * is `applyMiddleware()`.\r\n *\r\n * @returns A Redux store that lets you read the state, dispatch actions\r\n * and subscribe to changes.\r\n */\r\nexport default function createStore<S, A extends Action, Ext = {}, StateExt = never>(reducer: Reducer<S, A>, enhancer?: StoreEnhancer<Ext, StateExt>): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext;\r\nexport default function createStore<S, A extends Action, Ext = {}, StateExt = never>(reducer: Reducer<S, A>, preloadedState?: PreloadedState<S>, enhancer?: StoreEnhancer<Ext, StateExt>): Store<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext;\r\n"}}
